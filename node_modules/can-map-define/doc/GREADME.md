
- <code>[__can-map-define__ Object](#can-map-define-object)</code>
  - <code>[define Object\<String,[attrDefinition](#attrdefinition-object)\>](#define-objectstringattrdefinitionattrdefinition-object)</code>
  - <code>[attrDefinition Object](#attrdefinition-object)</code>
  - <code>[get( [lastSetValue] )](#get-lastsetvalue-)</code>
  - <code>[get( lastSetValue, setAttrValue(value) )](#get-lastsetvalue-setattrvaluevalue-)</code>
  - <code>[remove( currentValue )](#remove-currentvalue-)</code>
  - <code>[serialize( currentValue )](#serialize-currentvalue-)</code>
  - <code>[set( [newVal,] [setValue] )](#set-newval-setvalue-)</code>
  - <code>[constructorFunc](#constructorfunc)</code>
  - <code>[defaulter()](#defaulter)</code>
  - <code>[defaultVal](#defaultval)</code>
  - <code>[constructorFunc](#constructorfunc)</code>

## API

##  `{Object}`


# can-map-define



### <code>Object</code>

### define `{Object\<String,[attrDefinition](#attrdefinition-object)\>}`


Defines the
type, initial value, get, set, remove, and serialize behavior for attributes
of a [can.Map].



#### <code>Object\<String,[attrDefinition](#attrdefinition-object)\></code>
A map of
attribute names to [attribute definition](#attrdefinition-object)
objects.

### attrDefinition `{Object}`


Defines the type, initial value, and get, set, and remove behavior for an attribute of a [can.Map].



#### <code>Object</code>

- __value__ <code>{[value](#defaulter)()|*}</code>:
  Specifies the initial value of the attribute or
  a function that returns the initial value. For example, a default value of `0` can be 
  specified like:
  
      define: {
        prop: {
          value: 0
        }
      }
  
  `Object` types should not be specified directly on `value` because that same object will
  be shared on every instance of the Map.  Instead, a [value function](#defaulter) that 
  returns a fresh copy can be provided:
  
      define: {
        prop: {
          value: function(){
            return {foo: "bar"}
          }
        }
      }
  
- __Value__ <code>{function}</code>:
  Specifies a function that will be called with `new` whose result is
  set as the initial value of the attribute. For example, if the default value should be a can.List:
  
      define: {
        prop: {
          Value: can.List
        }
      }
  
- __type__ <code>{undefined(newValue, attrName)|String}</code>:
  Specifies the type of the 
  attribute.  The type can be specified as either a undefined 
  that returns the type coerced value or one of the following strings:
  
   - `"string"` - Converts the value to a string.
   - `"date"` - Converts the value to a date or `null if the date can not be converted.
   - `"number"` - Passes the value through `parseFloat`.
   - `"boolean"` - Converts falsey, `"false"` or `"0"` to `false` and everything else to true.
   - `"*"` - Prevents the default type coersion of converting Objects to [can.Map]s and Arrays to [can.List]s.
  
  The following example converts the `count` property to a number and the `items` property to an array:
  
       define: {
         count: {type: "number"},
         items: {
           type: function(newValue){
             if(typeof newValue === "string") {
               return newValue.split(",")
             } else if( can.isArray(newValue) ) {
               return newValue;
             }
           }
         }
       }
  
- __Type__ <code>{function}</code>:
  A constructor function that takes 
  the value passed to [can.Map::attr attr] as the first argument and called with 
  new. For example, if you want whatever
  gets passed to go through `new Array(newValue)` you can do that like:
  
      define: {
        items: {
          Type: Array
        }
      }
  
  If the value passed to [can.Map::attr attr] is already an Array, it will be left as is.
  
- __set__ <code>{[set](#set-newval-setvalue-)(newVal, setValue)}</code>:
  A set function that specifies what should happen when an attribute
  is set on a [can.Map]. `set` is called with the result of `type` or `Type`. The following
  defines a `page` setter that updates the map's offset:
  
      define: {
        page: {
          set: function(newVal){
            this.attr('offset', (parseInt(newVal) - 1) * 
                                 this.attr('limit'));
          }
        }
      }
  
- __get__ <code>{[get](#get-lastsetvalue-)(lastSetValue)}</code>:
  A function that specifies how the value is retrieved.  The get function is 
  converted to an [can.compute.async async compute].  It should derive its value from other values
  on the map. The following
  defines a `page` getter that reads from a map's offset and limit:
  
      define: {
        page: {
          get: function (newVal) {
  		  return Math.floor(this.attr('offset') / 
  		                    this.attr('limit')) + 1;
  		}
        }
      }
      
  A `get` definition makes the property __computed__ which means it will not be serialized by default.
  
- __remove__ <code>{[remove](#remove-currentvalue-)()}</code>:
  A function that specifies what should happen when an attribute is removed
  with [can.Map::removeAttr removeAttr]. The following removes a `modelId` when `makeId` is removed:
  
      define: {
        makeId: {
          remove: function(){
            this.removeAttr("modelId");
          }
        }
      }
  
- __serialize__ <code>{[serialize](#serialize-currentvalue-)(value, attr)|Boolean}</code>:
  Specifies the behavior of the 
  property when [can.Map::serialize serialize] is called. 
  
  By default, serialize does not include computed values. Properties with a `get` definition
  are computed and therefore are not added to the result.  Non-computed properties values are
  serialized if possible and added to the result.
  
      Paginate = can.Map.extend({
        define: {
          pageNum: {
            get: function(){ return this.offset() / 20 }
          }
        }
      });
      
      p = new Paginate({offset: 40});
      p.serialize() //-> {offset: 40}
  
  If `true` is specified, computed properties will be serialized and added to the result.
  
      Paginate = can.Map.extend({
        define: {
          pageNum: { 
            get: function(){ return this.offset() / 20 },
            serialize: true
          }
        }
      });
  
      p = new Paginate({offset: 40});
      p.serialize() //-> {offset: 40, pageNum: 2}
      
      
  If `false` is specified, non-computed properties will not be added to the result.
  
      Paginate = can.Map.extend({
        define: {
          offset: {
            serialize: false
          }
        }
      });
  
      p = new Paginate({offset: 40});
      p.serialize() //-> {}
  
  If a [serialize function](#serialize-currentvalue-) is specified, the result
  of the function is added to the result.
  
      Paginate = can.Map.extend({
        define: {
          offset: {
            serialize: function(offset){
              return (offset / 20)+1
            }
          }
        }
      });
  
      p = new Paginate({offset: 40});
      p.serialize() //-> {offset: 3}
      
  

### <code>get( [lastSetValue] )</code>


  Defines the behavior when a value is read on a [can.Map]. Used to provide properties that derive their value from 
  other properties of the map, or __update__ their value from 
  the changes in the value that was set. 


1. __lastSetValue__ <code>{*}</code>:
  The value last set by `.attr(property, value)`.  Typically, _lastSetValue_ 
  should be an observable value, like a [can.compute] or promise. If it's not, it's likely 
  that a [define.set](#set-newval-setvalue-) should be used instead.
  

- __returns__ <code>{*}</code>:
  The value of the property.
  

### <code>get( lastSetValue, setAttrValue(value) )</code>


  Asynchronously defines the behavior when a value is read on a [can.Map]. Used to provide property values that
  are available asynchronously. 


1. __lastSetValue__ <code>{*}</code>:
  The value last set by `.attr(property, value)`.
  
1. __setAttrValue__ <code>{function(value)}</code>:
  Updates the value of the property. This can be called
  multiple times if needed.
   

### <code>remove( currentValue )</code>



- __returns__ <code>{*|false}</code>:
  If `false` is returned, the value is not removed.
  

### <code>serialize( currentValue )</code>



1. __value__ <code>{*}</code>:
  The current value of the attribute. 
  
1. __attr__ <code>{String}</code>:
  The name of the attribute being serialized.
  

- __returns__ <code>{*|undefined}</code>:
  If `undefined` is returned, the value is not serialized.
  

### <code>set( [newVal,] [setValue] )</code>


A set function defines the behavior of what happens when a value is set on a
[can.Map]. It is typically used to:

 - Add or remove other attributes as side effects
 - Coerce the set value into an appropriate action

The behavior of the setter depends on the number of arguments specified. This means that a
setter like:

    define: {
      prop: {
        set: function(){}
      }
    }

behaves differently than:

    define: {
      prop: {
        set: function(newVal){}
      }
    }


1. __newVal__ <code>{*}</code>:
  The undefined coerced value the user intends to set on the
  can.Map.
  
1. __setValue__ <code>{function(newValue)}</code>:
  A callback that can set the value of the property
  asyncronously.
  

- __returns__ <code>{*|undefined}</code>:
  If a non-undefined value is returned, that value is set as
  the attribute value.
  
  
  If an `undefined` value is returned, the behavior depends on the number of
  arguments the setter declares:
  
   - If the setter _does not_ specify the `newValue` argument, the attribute value is set
     to whatever was passed to [can.Map::attr attr].
   - If the setter specifies the `newValue` argument only, the attribute value will be removed.
   - If the setter specifies both `newValue` and `setValue`, the value of the property will not be
     updated until `setValue` is called.
  
  

### <code>constructorFunc</code>


A constructor function can be provided that is called to convert incoming values set on this property, like:

    define: {
      prop: {
        Type: Person
      }
    }


### <code>defaulter()</code>


A function can be provided that returns the default value used for this property, like:

    define: {
      prop: {
        value: function(){ return []; }
      }
    }

If the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object.  For example, if the property `value` above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).


- __returns__ <code>{*}</code>:
  The default value.  This will be passed through setter and type.
  

### <code>defaultVal</code>


Any value can be provided as the default value used for this property, like:

    define: {
      prop: {
        value: 'foo'
      }
    }


1. __defaultVal__ <code>{*}</code>:
  The default value, which will be passed through setter and type.
  

### <code>constructorFunc</code>


A constructor function can be provided that is called to create a default value used for this property, like:

    define: {
      prop: {
        Value: Array
      },
      person: {
      	Value: Person
      }
    }

